
TREAP

import java.util.*;
class Solution {
 public String smallestEquivalentString(String A, String B, String S) {`
 int[] graph = new int[26];
 for(int i = 0; i < 26; i++) {
 graph[i] = i;
 }
 for(int i = 0; i < A.length(); i++) {
 int a = A.charAt(i) - 'a';
 int b = B.charAt(i) - 'a';
 int end1 = find(graph, b);
 int end2 = find(graph, a);
 if(end1 < end2) {
 graph[end2] = end1;
 } else {
 graph[end1] = end2;
 }
 }
 StringBuilder sb = new StringBuilder();
 for(int i = 0; i < S.length(); i++) {
 char c = S.charAt(i);
 sb.append((char)('a' + find(graph, c - 'a')));
 }
 return sb.toString();
 }
 private int find(int[] graph, int idx) {
 while(graph[idx] != idx) {
 idx = graph[idx];
 }
 return idx;
 }
 public static void main(String args[]){
Scanner sc=new Scanner(System.in);
String A= sc.next();
String B = sc.next();
String substr= sc.next();
System.out.println(new Solution().longestIncreasingPath(matrix));
 }
}

------------------------------------------------------------------------------------------
LEXOGRAPHIC

import java.util.*;

class Solution {
    public String smallestEquivalentString(String A, String B, String S) {
        int[] graph = new int[26];
        for (int i = 0; i < 26; i++) {
            graph[i] = i;
        }
        for (int i = 0; i < A.length(); i++) {
            int a = A.charAt(i) - 'a';
            int b = B.charAt(i) - 'a';
            int end1 = find(graph, b);
            int end2 = find(graph, a);
            if (end1 < end2) {
                graph[end2] = end1;
            } else {
                graph[end1] = end2;
            }
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < S.length(); i++) {
            char c = S.charAt(i);
            sb.append((char) ('a' + find(graph, c - 'a')));
        }
        return sb.toString();
    }

    private int find(int[] graph, int idx) {
        while (graph[idx] != idx) {
            idx = graph[idx];
        }
        return idx;
    }

    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        String A = sc.next();
        String B = sc.next();
        String S = sc.next();
        System.out.println(new Solution().smallestEquivalentString(A, B, S));
    }
}

----------------------------------------------------------------------------------------------
MATRIX

import java.util.Scanner;

public class Longest_Increasing_Path_in_a_Matrix {
    private int[] dx = new int[]{0, 0, -1, 1};
    private int[] dy = new int[]{1, -1, 0, 0};

    public int longestIncreasingPath(int[][] matrix) {
        if (matrix == null || matrix.length == 0) {
            return 0;
        }

        int longest = 0;
        int m = matrix.length;
        int n = matrix[0].length;

        // Longest path starting from position (i, j)
        int[][] dp = new int[m][n];

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                longest = Math.max(longest, dfs(i, j, matrix, dp));
            }
        }

        return longest;
    }

    private int dfs(int row, int col, int[][] matrix, int[][] dp) {
        if (dp[row][col] > 0) {
            return dp[row][col];
        }

        int m = matrix.length;
        int n = matrix[0].length;
        int currentLongest = 0;

        for (int c = 0; c < 4; c++) {
            int i = row + dx[c];
            int j = col + dy[c];

            if (i >= 0 && i < m && j >= 0 && j < n && matrix[row][col] < matrix[i][j]) {
                currentLongest = Math.max(currentLongest, dfs(i, j, matrix, dp));
            }
        }

        dp[row][col] = 1 + currentLongest;
        return dp[row][col];
    }

    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int m = sc.nextInt();
        int n = sc.nextInt();
        int matrix[][] = new int[m][n];

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = sc.nextInt();
            }
        }

        System.out.println(new Longest_Increasing_Path_in_a_Matrix().longestIncreasingPath(matrix));
    }
}

------------------------------------------------------------------------------------------------

ANCESTOR

import java.util.*;

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == p || root == q) return root;
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        return left == null ? right : right == null ? left : root;
    }
}

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int val) {
        this.val = val;
        left = null;
        right = null;
    }
}

public class LCA {
    static TreeNode root;
    static TreeNode temp = root;

    void insert(TreeNode temp, int key) {
        if (temp == null) {
            root = new TreeNode(key);
            return;
        }
        Queue<TreeNode> q = new LinkedList<>();
        q.add(temp);

        // Do level order traversal until we find an empty place.
        while (!q.isEmpty()) {
            temp = q.peek();
            q.remove();
            if (temp.left == null) {
                temp.left = new TreeNode(key);
                break;
            } else {
                q.add(temp.left);
            }

            if (temp.right == null) {
                temp.right = new TreeNode(key);
                break;
            } else {
                q.add(temp.right);
            }
        }
    }

    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        String str[] = sc.nextLine().split(" ");
        LCA lca = new LCA();
        root = new TreeNode(Integer.parseInt(str[0]));
        for (int i = 1; i < str.length; i++) {
            lca.insert(root, Integer.parseInt(str[i]));
        }
        Solution sol = new Solution();
        TreeNode res = sol.lowestCommonAncestor(root, lca.temp.left, lca.temp.right);
        System.out.println(res.val);
    }
}
------------------------------------------------------------------------------------------------------
